# 17.复制

> 最主要的作用是提高系统的整体表现

为什么复制可以提高表现？

* 减少延迟。复制将文件分布在不同的地方，可以使数据更靠近用户
* 提高可用性。一个服务器挂掉，客户依然可以继续执行操作
* 提高可用性。如果一个服务器挂掉，你应该在另一个服务器上备份，备份这个过程就是复制
* 通过一致性提高可信度。例如你从一个服务器上读到一个数据，你相信了它，可能有另一个人修改了这个数据，你还相信你从一个服务器上读到的数据么？但是如果从两个副本读到了同样的数据，你就能相信它了。因此复制提高了可信度

但你设计一个分布式系统的复制机制时，你需要考虑以下几点：

* 如何将逻辑上的复制映射到物理上的复制
* 复制的要求？用户修改一个文件时，同时更新所有的副本还是仅更新那一个文件？透明性：你在操作文件时，看不到背后的复制是如何进行的。
* 用什么算法满足复制的要求？

## 保持一致性的几种级别

### 严格的一致性

任何操作都是实时发生。永远即时读取最近的一次写操作后的文件。要求有绝对的全局时间，任何修改都会立即被看到，并且永远有一个全局时间标记的排序。这种方法代价很高。

### 序列化的一致性

> 相比较于严格的一致性，这种方法没有全局时间标记，那如何实现一致性呢？

例1:   
 想象你在网上购买种子，读操作相当于你看到种子的剩余数量，写操作相当于付钱。

例2:  
 机器1对文件`x`写操作，机器2对文件`x`读操作，谁应该先发生？  
 如果读先于写，机器2只能读到旧数据，反之，读到新数据。

例3:  
 机器1进行`r1[x]->w1[x]`，机器2进行`r2[x]->w2[x]`。

* `w1[x] r1[x] w2[x] r2[x]`：❌不能颠倒在一个机器上的执行顺序
* `r1[x] w1[x] r2[x] w2[x]`：✅对每个机器来说，顺序都保持不变
* `r2[x] w2[x] r1[x] w1[x]`：✅因为无所谓谁先进行写操作。例如客户网购种子，无论系统背后让谁先付款都没问题，因为客户实际上不知道谁先付款的，如果他要付款的时候正好种子没有了，他会认为是自己下单比别人晚
* `r1[x] r2[x] w1[x] w2[x]`：✅
* `r2[x] r1[x] w2[x] w1[x]. / r2[x] r1[x] w1[x] w2[x]`：✅

**主要思想：每个机器上的顺序不能颠倒，至于每个机器间的顺序，取决于你的系统设定**

### 事务过程中复制的一致性

* 渴望/同步复制：如果你修改一个副本，所有的副本立马同步更新。
  * 昂贵的commit。完成一个事务，同步更新所有副本，然后再同步commit所有副本
  * 当一个事务花费很长时间时。一个事务花费很长时间在一个副本上，过了一会，当要执行同样的事务在另一个副本时，另一个副本处在当前不可用状态，就会自动跳过这个副本，最后整个复制就会失败
  * 同时更新所有副本时，一旦一个副本端挂掉，那么同步化就失败了，你必须一直等待，或者终止然后重启这个事务
* 懒惰/异步复制：如果修改一个副本，那么只修改主副本
  * 一旦主副本端挂掉，修改就作用于另一个副本。
  * 如果执行一个很多步骤很费时的事务，可以将这个事务分解成若干个小事务做作用在若干个副本上，这样费时的事务问题也解决了。
  * 缺点：事务1作用于副本A，事务2就只能作用于副本B，最后你想合并A和B最后的结果，由于这两个事务的先后顺序对副本A和B来说是相反的，对A来说是：`1->2`，对B来说是：`2->1`。解决方案：设定其中一个为主副本，按照它的顺序执行。

