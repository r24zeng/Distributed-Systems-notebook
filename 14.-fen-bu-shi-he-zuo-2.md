# 14.分布式合作2

## 互斥

> 即在某段任务期间，一致同意的进程执行的顺序
>
> ### 成功的算法必须满足：
>
> * 正确性：系统不能同时进行多个进程
> * 服务的先后秩序
> * 活着的进程：如果一个客户端挂了，服务器没有收到回应，就会知道这个客户挂了，则向清楚数据，把数据的权限给其他用户。换句话说，好的事情只要给足够的时间一定会发生。例如，某个人获得进入许可是一件好的事，那么最终这个人肯定会获得许可

这个算法有一个瓶颈，分布式系统允许并行工作来提高表现，但是这个算法不允许多个进程同时发生。如果解决这个问题呢？两个方法：

* 基于**许可**的解决方案
* 基于**密钥**的解决方案

### 基于许可的方案

* 找一个调解员：你找调解员要许可，如果调解员说“OK”，那么你就有数据操作权限，否则调解员什么都不会回复，仅仅把你放进队列中等待，一旦上一个人完成了操作，调解员回复你说“OK”，你才获得权限
* 根据时间标记决定顺序：客户端A和B同时发送请求，对比两个人的时间标记，谁的时间标记低，谁就先获得权限，一旦完成任务离开时，发送“OK”给另一个人，然后另一个人就获得权限。如何解决若其中某个客户端失败（挂掉）的情况呢？意思是当一个人挂掉了，他甚至无法给下一个人发送“OK”的信号。对于集中化系统，这种方法奏效，对于分布式系统，这种方法没有作用。

### 基于密钥的方案

你何时获得权限取决于你在一个环形队列的位置，密钥被上一个人传递给你当上一个人完成了任务。例如，`5`传递密钥给`6`，并且让`7`知道`6`拿着钥匙，一旦`6`挂了，根据设置的超出时间，`7`知道`6`挂了，然后`5`再把钥匙直接传给`7`。

### 选举机制

> 有时候需要调解员机制，但调解员挂掉的时候如何解决呢？

如果有很多调解员做一件事情是非常不明智的选择，因为他们可能会有不一样的回复，那么你要相信谁？**解决方法：**

* 最高ID的客户端可以成为新的调解员
  * 4 发送请求给 7（当前调解员），7 看起来挂了因为超出时间了，那么 4 就问他的邻居 5，6，7 谁能成为新的调解员，活着的ID 5 和 6 回复说“OK”，5 和 6 开始发起一个选举，询问他的邻居们谁可以成为新的调解员，5 问了 6 和 7，7 挂了，所以只有 6 回复说“OK，我能成为新的调解员”，同时，6 也发起一个选举，发送请求给 7，7 挂了所以没有回复，这时候 6 就赢得了选举。然后他告诉所有人，“我成为了新的调解员”。**注：仅向比自己ID高的人发送选举请求**。
* 基于环形的选举机制
  * `0-1-2-3-4-5-6-7-0`。从 3 开始，3 设置了超时时间，发现有人挂了，就把自己的ID加到要传递的信息上： `[3]`，4 也把自己的ID加上：`[3,4]`， ……， 直到 6 把信息传递下去给 7: `[3,4,5,6]`，7 没有任何反应，信息传递给了 0，0 终于知道是 7 挂了，加上自己的ID：`[3,4,5,6,0]`，然后 1，2, 3 都知道是 7 挂了，消息传回到 3，3 选出了ID最高的 6 为新的调解员，就告诉所有人 6 是最新的调解员。 

