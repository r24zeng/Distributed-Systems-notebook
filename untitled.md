# 13.分布式合作

## 物理时钟（UTC）

> 精确与准确是最重要的问题，代价很高。意味着你要决定需要多同步以及多频繁的查询时间

每台机器都有自己的石英时钟，所以我们需要NTP（netorking time protocal）- 网络时间协议。有三种办法获得UTP时间，（1）用PRC询问UTC服务器；（2）用无线电盒子；（3）用标准的US卫星

### 保持UTC服务器时间同步

用户A记录发送请求给UTC服务器B的时间`t1`, 服务器B记录收到请求的时间`t2`和回复请求的时间`t3`，用户A记录收到回复的时间`t4`，那么我们就得到了\(`t2-t1`\)和\(`t4-t3`\)。那么用户就可以计算平均的延迟时间（偏移量）$\theta= \(\(T\_2-T\_1\)+\(T\_4-T\_3\)\)/2$，然后调整自己的时间与UTC同步。

这个期间消息量不会很多，只发消息给特定的用户即可。

### 无需UTC服务器的广播算法

用一个管理时间的服务器询问每个机器的时间，然后计算平均值，强制所有机器同步到这个时间。

注意：永远不要回调时间，避免突然的改变丢失事件，必须平滑的调整时间，比如说快进或者慢进。

这个期间有大量的消息产生，向每个用户发送消息，然后每个用户返回消息。

## 逻辑时钟（Lamport 时钟，根据事件的关系推导顺序）

> 无需同步时钟，只需要对事件发生对顺序达成一致即可，不需要考虑物理时钟

不考虑所有时间对排序，只考虑我们关心的部分事件，这样花费少一些。

传递性：集中化的情况下，很容易知道事件的顺序；但是在分布式的系统中，我们不知道事件发生的先后顺序。通过谁发送消息给谁，我们可以推断出事件的顺序。

### 2个法则

* 同一个进程（机器）中，事件1（时间标记$L\_1$）发生在事件2之前，则其时间标记增加1，为$L\_2=L\_1+1$
* 不同进程中:
  * 如果用户$P\_i$发送消息m出去，此时这个动作的时间标记为$L\_i$
  * 接收消息的用户$P\_j$，此时的时间标记为$max\(L\_i, t\)$, `t`是此用户接收消息前的时间标记

### 标记的过程举例

* 给$P\_1$和$P\_2$初始时间，$P\_1\(0\)$，$P\_2\(0\)$
* $P\_1$执行了事件，时间标记增加1，$P\_1=1$，然后发送消息给$P\_2$，此时时间标记为$P\_1=2$
* $P\_2$接收了消息，比较目前的时间与收到的消息的时间，$max\(0,2\)=2$，因此$P\_2=2$，因为接收了消息，所以此时的时间标记增加1，$P\_2=2+1=3$。然后发送消息给$P\_4$，此时时间标记为$P\_2=3+1=4$
* $P\_3$接收消息，$max\(0,4\)=4$，然后自增1，则目前的事件为$P\_3=4+1=5$

### 向量时钟

> 多维时钟是lamport时钟的延伸，多进程中对事件排序

例如：$P\_1\(0,1,0\)$与$P\_2\(1,1,0\)$，比较这两个时间标记，如果至少有一个维度高于相应的维度，并且其他维度都相等，我们就说$P\_2$高于$P\_1$，$P\_2$在$P\_1$后发生。

但是如果A先于B发生，不意味着`A->B`的因果关系。

