# 19.恢复

> 失败了，重启，看日志恢复状态

## 恢复的协议

在很多个端口修改数据时，要么都commit了，要么都终止了。这一点必须保证从一种状态到另一种状态到稳定和可持续性。例如如果一个端口commit，另一个端口失败了，你必须要知道如何恢复这个失败到端口得到commit。

## 本地恢复

假设你有一个硬盘和内存空间，要进行操作时，将文件从硬盘转移到内存中操作，因为这样操作更快捷，操作完后再返回储存到硬盘中。在执行一系列的事务时有以下两种情况：

* 情况一：如果事务在内存中，还未commit就失败了，则直接放弃这些食物
* 情况二：如果事务在内存中已经commit后失败，还未来得及转移到硬盘中。避免修改丢失，我们希望内存中的修改会冲刷到硬盘中。

解决方案：建一个日志记录事务的操作过程，日志可以在本地硬盘上或者任意一个服务器端的硬盘中，当内存挂掉时，立马查看日志，若已经commit了，就按照日志的动作重新做一遍从而保证完成的修改一定会完成，若还没有commit就直接放弃修改。

计算机科学中有个数据库的概念叫ACID（原子性，一致性，隔离性，可持续性），恢复主要解决的**可持续性**。

如果系统很长时间都没有挂掉，那么日志就会很长，浪费了极大的空间。解决方案：使日志可覆盖循环，意思是新的可以覆盖旧的，像环形那样，有间隔的将日志存储到硬盘中（check pointing），其他最新的日志留在内存中，这样减少了恢复时间。每个服务器都有这样的日志，叫**WAL（write ahead log）**。

## 全局恢复

如果若干个事务在不同的端口执行，一旦有一个端口失败了如何恢复呢？解决方法：2PL（2次commit）。从协调员完成任务开始**2PC**时记录日志。

一定要指派一个协调员，任何端口都可以成为协调员，但是当前一定需要一个端口成为协调员。这种方法有以下几个步骤：  
 （1）协调员和各个端口自己做自己的事务，当协调员做完了，就问其他端口“你们准备好了commit么？“   
 （2）端口收到消息开始投票“Yes”或者“No"，反馈给协调员  
 \(3\) 协调员如果收到了所有的投票都是“Yes”就发送命令给所有端口“全局commit“，否则一旦有端口投票“No“或者有的端口没回应（abort），则发送命令“全局终止“，最后所有端口完成指令后告诉协调员"完成"。  


这就意味着协调员要知道所有端口的状态信息。每个决定（信息往返了两次）都是持续性的。

可能存在的失败：

* 协调员在发送“准备好了commit“前失败了，日志是空的，那么当协调员恢复了，什么都不用干
* 协调员在发送完“准备好了commit“后就失败了，或者在收到所有其他端口投票前失败了。协调员一旦恢复后，终止所有操作
* 协调员在发送“全局commit或abort"前失败了，当其恢时，查看日志要么继续发送commit要么终止
* 协调员在发出“全局commit“后失败了，当恢复的时候查看其日志，可以选择继续commit或者直接终止
* 在其他端口失败的情况1:在投票“准备好了commit”后失败了，当恢复时查看日志，看不到协调员返回的指令，因此不知道此时大家是commit还是abort了，那么只要再问协调员是否commit
* 在其他端口失败的情况2:同上一条。但是此时协调员也正好挂掉了，它开始运行终止协议。两个解决方案：不停的询问协调员；随机问其他任意端口是否“commit”。但这两种办法都是很费时间的，比如协调员一直没恢复，或者问的端口也同时都挂掉了（这叫做不确定失败）。
* 其他端口在完成了“commit或abort”后返回消息“完成”给协调员时失败了，那么当恢复的时候只要再向协调员发送一次消息即可

2PC：2次commit，一次时投票commit， 一次是决定commit。

2PC（2相commit）不等于 2PL（2相锁）

