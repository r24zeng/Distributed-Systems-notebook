# 16.事务之并行化控制

## 两段锁协议（2PL）

> 当你需要读操作就找管理员要读的锁，要进行写操作就找管理员要写的锁, 在一个事务周期内持续获得锁（更高级别的锁），直到事务完成，释放所有的锁

如果你开始了写操作，任何人都没有权限拿到写的锁。

**死锁**可能会发生根据你的上锁协议。例如，一个事务正在进行读操作，等待一个写锁，另一个事务正在进行写操作，等待读锁，这时候死锁就发生了。

### 严格的2PL

> 拿着所有的锁直到事务完成
>
> * 中心化2PL：一个管理员负责管理所有事务的锁
> * 分布式2PL：锁都在数据存放的一端，意味着部分上锁。这种方式更有利于分布式系统，但是会有耗费大量的消息传递

### 死锁

> 我拿着你想要的资源，你拿着我想要的资源，都在等待，造成死锁

解决：其中一个人拿着非共享的资源。（共享锁：若我有一个读锁，你也要进行读操作，这两个操作不冲突，那么你也可以拿到读锁，这样操作都继续正常进行，这个读锁就叫做共享锁。这里的“资源”都是指“锁”）

### 死锁的管理（这是有管理员的情况）

> 无论是中心化还是分布式系统，唯一的解决办法都是杀掉其中一个事务。

三种层次的处理方法：

* 防止死锁发生：需要的锁提前申请，确保死锁根本不会发生。（高级别）
* 避免潜在的死锁：按照一定的秩序索取锁，避免可能发生的死锁。（中等级别）
* 检测和恢复：检查是否有死循环，杀掉其中的一个事务，通常杀掉较之年轻的事务，其拥有的锁全部释放，然后重启这个事务。（低级别）

检测：某个运行方了解其他人等待什么锁，记录这个信息并且将消息传递给另一个人，直到某个人看到了死锁，则要么这个人自己终止打破死锁，要么叫停其他人。

### 按时间标记排序（这是锁在数据端的情况）

> 有很多事务在等待，我给每个事务分配一个独一无二的时间标记，按照时间标记序列化，我按照时间标记来服务他们

如果无冲突，我就会并行化为他们服务，如果有冲突，我将会按顺序为他们服务。

每个数据文件有一个时间标记：

* 文件`x`的读时间标记`read_ts(x)`：很多人都成功读取了这个文件，这个文件的时间标记就变成其中最大的ts。例如：`T2`读了`x`，`read_ts(x) -> read_ts(2)`;`T3`读了`x`，`read_ts(2) -> read_ts(3)`;`T1`最后成功读了`x`，`read_ts(3)`保持不变，因为`3`是最大的时间标记。
* 文件`y`的写时间标记`write_ts(y)`：谁有最大的时间标记，谁能脱颖而出进行写操作。

**对同一文件来说，读操作只与写操作矛盾，比较读的时间标记`r_?(x)`与文件当前的写的时间标记`w-ts(x)`，确保`?>=w-ts(x)`，则可以进行，执行完后视情况更新当前文件的读操作；对同一文件来说，写与读写操作都矛盾，因此要比较写的时间标记`w_?(x)`与文件当前的读`r-ts(x)`和写`w-ts(x)`的时间标记，确保`?>=r-ts(x)和w-ts(x)`。**（有待进一步考证）

举例：

**文件`x`的初始状态：**

| r/w\(x\) | timestamp |
| :--- | :--- |
| r-ts\(x\) | 0 |
| w-ts\(x\) | 0 |

\(1\) w\_1\(x\)   
 时间标记为1的想要写，我们知道写操作与读写都矛盾，由于1 &gt; 0因此可以进行写操作，执行完写操作后, 更新 w-tx\(x\):1

| r/w\(x\) | timestamp |
| :--- | :--- |
| r-ts\(x\) | 0 |
| w-ts\(x\) | 1 |

\(2\) r\_2\(x\)   
 时间标记为2的想要读，我们知道读操作只与写操作矛盾，由于2 &gt; 1, 所以可以执行读，执行完后更新 r-tx\(x\): 2

| r/w\(x\) | timestamp |
| :--- | :--- |
| r-ts\(x\) | 2 |
| w-ts\(x\) | 1 |

\(3\) r\_1\(x\)   
 时间标记为1的想要读，我们知道读操作只与写操作矛盾，由于 1 = 1, 所以可以进行读操作，又因为 1 &lt; 2, 所以无需更新 r-ts\(x\)

| r/w\(x\) | timestamp |
| :--- | :--- |
| r-ts\(x\) | 2 |
| w-ts\(x\) | 1 |

\(4\) w\_1\(x\)   
 时间标记为1的想要进行写操作，因为写操作与读写都矛盾，由于 1 &lt; 2, 所以不能执行写操作，无需更新时间标记

| r/w\(x\) | timestamp |
| :--- | :--- |
| r-ts\(x\) | 2 |
| w-ts\(x\) | 1 |

一般来说，如果你终止了一个事务，就必须终止所有与之相关的事务，但是在时间标记排序的方法下，你只需要终止一个事务，然后给这个事务更高的时间标记，重启这个事务即可。

