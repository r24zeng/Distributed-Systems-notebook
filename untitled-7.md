# 9.通信（RPC）

> 层级之间如何传递消息的？

由于中间层不是完全隐藏的，因此需要了解一些通信的实现方法。

**暂时通信**：当用户发送消息给服务器时，没有中间层存储信息，意思就是服务器必须即时响应。

**长期通信**：有中间层存储信息直到服务器接收信息。

**异步性**：当用户发送消息时，消息放在有序消息队列中，此时用户无需处于等待状态，而是可以做其他的事情。但也有问题，比如你搜一个网页，但是发送的请求在队列里等待，等到你搜下一个网页的时候时候，你的上一个请求才被响应，这时你看到的是上一个搜到的结果，就很奇怪。优点是在等待期间你可以处理其他的任务，节省了时间。

**同步性**：当用发送请求时，必须等待直到服务器响应请求。想象一下，如果服务器没有运行，这样你的浏览器就会永远处在等待状态，又或者服务器在运行，你可以立马得到回应。

### 为什么要建立中间层呢？

对于**用户/服务器**模型，有很多地方会导致传输失败：

* 发送请求至服务器途中失败
* 发送请求到服务器后，服务器处理的过程中失败
* 发送回复到用户端的途中失败
* 发送回复到用户端时，用户接收失败

总之，中间层就是一个很好到解决办法，它可以及时识别失败，然后让客户端再发送一次请求。

## 信息传递（RPC）

> 要让消息传递机制简单且易于理解，这样大家才喜欢用

### RPC是什么？

* 全称：remote procesure call，远程过程调用
* 远程过程调用的传參和传递结果都是在机器间运行
* 程序调用方或者调用方和接收方都会死掉

**RPC**的运行原理：用户端想要调用远程服务器，只需要调用本地，然后中间层将会调用远程服务器，最后服务器将结果返回给用户。**RPC**就是这个中间层。这种机制简化了人们的操作，因此很受欢迎。

**RPC**核心组件：

* 客户（client）：服务的调用方
* 服务端（server）：真正的服务提供者
* 客户端存根（client stub）：存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方
* 服务端存根（server stub）：接收客户端发送过来的消息，将消息解包，并调用本地的方法

**RPC**的操作方式：客户端调用发出调用请求，客户端存根将"r"地址引用加要传递的参数编组，传递给服务端存根，服务端存根接收消息并将解组，传给服务端，服务端调用本地方法并将消息传回。

### 如何实现客户端到服务器的过程呢？

1. 如果客户和服务器在一台机器上，用户发送引用“r“（想像成一把钥匙），服务器能用"r"访问数据。如果它们不在一台机器上，远程服务器是无法用"r“访问数据的
2. 客户端发送消息给远程服务器，但是远程服务器不能识别这个消息。因此，我们必须保证它们有相同的架构
3. 如何处理协议的问题？（协议考虑的三大问题：信息的格式，次序，消息的解码方式）

解决方案：RPC参数传递。用户端每次发送消息都告诉服务器格式、读取顺序、信息的含义，并且直到服务器的地址，服务器接收到信息后，解组信息，从底部开始读取。

复制进/复制出：当客户端发送一个复制文件给服务器，服务器改变了这个文件，将文件传回，客户端知道文件修改了，则用修改后的文件替换之前的旧版本。这个过程只用参数传递的方法传递文件的”引用“地址，而不需要传递整个文件，这样大大节省了空间，尤其是大项目的时候。如果是小项目，当然可以传递整个文件内容。

#### 实际的RPC的缺点

客户端和服务器都知道彼此的地址，如果远程服务器换了地址或者换了台远程服务器，客户端不知道新的地址，那么任务就会失败。客户端必须要知道对接的是哪个服务器和服务器在哪台机器上。

\*\*解决方案：DCE\(client-to-server binding\)，属于中间层系统，是RPC的守护程序。

在服务器被调用前，在每个服务器都存储这一张表格，（服务器，端口）对，所有的服务器都要先到DCE中注册自己在操作系统中使用的端口及自己使用的协议，然后去一个目录管理的服务器注册自己的名字。当客户端调用服务器时，先去问目录管理的服务器那个服务器的IP，然后再去问DCE那个服务器对应的端口，从而达到绑定了客户端和服务器的目的。一旦新的服务器加入或者服务器更换，都会去这两个地方注册，确保客户端无论如何都能找到这个服务器。

大多数的**RPC**的实现都是通过_sockst_。socket交互包括：新建socket\(socket\)，绑定（bind），监听（listen），同意（accept），连接（ connect），发送（send），接收（recieve），关闭（close）。

**通过socket运行RPC的原理**：服务器的套接字打开，并且绑定端口，时刻监听并等待请求，直到请求到达后解除封闭状态。用户创建一个新的套接字，发送连接密钥给服务器，服务器就有权限访问消息了。这时，服务器其实是新建了一个套接字与之连接，从而保持监听是否有新的客户请求。直到关闭了端口，客户端与服务器的连接结束。

著名的套接字参考资料：Steves的《Unix Network parogramming》；《Beej's》。

## 面向消息的中间件

> 邮件系统是一个非常成功的例子，它是一个持续同步化通信的实例。

“PUT”将邮件加到一个序列后面，非等待调用，“GET”是等待调用，当特定的队列非空的时候删掉最长的正在等候的信息，直到队列非空时这个过程处于等待状态，“POLL”从优先队列读取信息，从不会处于等待状态，“NOTIFY”当某个指定队列收到新的信息立即安装一个处理程序。相当于，你发送邮件就是“PUT”，将你的邮件发送给带有接收人ID的特定队列，邮件系统只是相当于中间序列的存储系统和DCE，当你登录邮箱时，会自动有“NOTIFY”告诉你接收到了文件，当你读取邮件时用的是“POLL”，文件会从你的邮箱队列中移除出来。

