# 15.事务之序列化

> 事务即一连串动作的集合完成一件事

## 认识符号

T\_1 \(事务1\)包括：  
 r\_1\[x\]+w\_1\[x\]+c\_1   
 事务1对文件`x`的读操作，事务1对文件`x`的写操作，事务1 commit

事务是串行化的，而不是即时的。

分布式事务执行前，必须知道复制协议，即一旦一个机器获得一个复制文件，复制到所有机器上还是说将这个文件分解复制到所有机器上。

## 隔离

越多的并行化意味着越好的表现，并行化代表了分布式系统。所以在一个时间内只允许一个事务发生是不好的。我们想要高效的并行和隔离，但现在我们只能权衡一下，要更好的并行但是差一点的隔离。

## 丢失更新的问题

两个客户端都在进行事务，同时更新文件而不顾另一个客户端在干嘛，这样必然最后有一个事务成功，一个事务失败。

## 检索不一致的问题

例如：客户A和B银行卡里各有¥200，A取出来¥100，B理应看到两个账户一共¥400，可是他看到一共只有¥300了，这种还没commit的变动即时被读取了，叫做**脏读**。

如果你没有任何的隔离，就要非常小心，因为一旦发生了改变然后又被撤回（rollback），那么所有被影响的事务都会终止。

## 序列化

* w\_1\[x\], w\_2\[y\] 不冲突，因为操作不同的文件，称之为并行化
* r\_1\[x\], r\_2\[x\] 不冲突，因为都是只读，称之为并行化
* w\_1\[x\], r\_2\[y\] 不冲突，因为操作不同的文件，称之为并行化
* w\_1\[x\], w\_2\[x\] 冲突，因为写操作同一个文件，不能并行发生
* w\_1\[x\], r\_2\[x\] 冲突，因为同时操作一个文件，不能并行发生
* w\_1\[x\], r\_1\[x\] 不冲突，因为发生在同一个事务中，一个事物跟本身不可能发生冲突

序列化就是事务的顺序的意思。如果我们有隔离，那么我们就能保证数据的一致性。序列化系统将会和有同样序列化历史的序列化系统矛盾。

逻辑排序图可以找到序列化的顺序，但是如果这个图有圆形，那么这个系统就不是满足列化系统。

## 分布式事务序列化的步骤

* 本地事务必须先序列化，然后查找序列化历史
* 将两个序列化历史放在一起来变成一个全局的序列化，如果没有任何冲突，则是可行的

## 并行化控制

> 实时控制是很困难的，可以给冲突的操作上锁从而达到并行化目的

