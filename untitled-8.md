# 10.分布式命名

> 为了迅速找到想要的实体，命名非常重要，DNS是一个很好的例子，将IP映射到相应的URL。

为了快速找到服务器，我们需要知道机器的地址和名字。比如你发送邮件，对方邮箱地址和名字你必须知道。

## Name

* 纯名字（flat-naming system）：0或1组成，没有任何意义
* 非纯名字（readable name）：带有一定的信息，比如地址信息

## 两种服务

* 命名服务（基于结构的命名方式）：名字+属性，属性通常指网络地址，搜索时名字可以搜索到属性，或者启用名字解析搜索。例如文件系统和URL系统。
* 目录服务\(基于属性的命名方式\)：搜索时，名字可以搜索到属性，属性可以搜索到名字。例如邮件系统。

## URL 解析

> 通过URL名字发送到不同的名字空间

过程：找到网络地址（IP）-&gt; 机器 -&gt; 端口 -&gt; 目录 -&gt; 文件 -&gt; html。但机器无法识别 html，只能识别0或1，因此还html需要映射到0或1.

## 命名空间（例如 URL 中的 WWW）

文件系统是通过“/”来导航文件，“/”左右提供了重要的语境，这种方法极易插入新的“/”从而很容易拓展命名空间。因此命名空间提供组织和查找。

## 用单一的根节点创建的命名图

分为两种节点，一种是叶子节点，存储终极目标文件，一种是目录节点，存储目录路径。

分为三层：顶层是全局层，例如全球域名，数量及分布非常稳定，从全局层延伸到行政层，比如“Waterloo”，数量增多，分布相对稳定，但有时也会更改，再延伸到管理层，用户自己管理这些节点，可以理解为目录下的文件，数量非常多，非常不稳定，随时可能更改。

邮件的发送：已知对方的邮箱地址，先去查找全局层，比如说是哪个国家的地址，再去查找是哪个地区的，再查找是哪个机器和端口的，再查找是哪个人的地址，从上往下找，以防找不到对应的地址，最顶层必须非常稳定。全局层的更新非常少，可能一天只需要更新一次，因为顶层特别稳定，但其他两层更新非常频繁。顶层有很多复制，第二层有部分复制，底层没有复制。上面两层有用户端缓存，最底层偶尔会有用户端缓存。

## 导航的方式（名字解析）

* 迭代：用户给节点1（top/root server）发送请求，节点1能处理请求则处理，不能处理则返回报告用户处理不了，用户再给另一个节点发送节点，以此类推。用户和每个节点直接沟通并能及时收到反馈，决定是否继续发送请求取决于用户端。
* 递归：用户给节点1发送请求，节点1（top/root server）能处理则自己处理，不能处理则传给下一个节点2处理，节点2\(middle server\)能处理则自己处理，不能处理则传给下一个节点3\(bottom server\)处理，节点3若是能处理，处理完后反馈给节点2已经处理完毕，节点2反馈给节点1已经处理完毕，节点1最终反馈给用户已经处理完毕。
  * 缺点：要求每个节点都很厉害，能独立解析完整的名字，通常全局/根节点只能完成迭代的要求
  * 优点一：导航过程中（处理完后从底层逐级向上反馈有利于缓存）每一级的缓存能极大提高导航效率，和沟通效率
  * 优点二：沟通比较有效率，代价小很多，直接去找下一个符合要求的节点，并且通常层级间的物理距离较近，所以沟通比迭代更高效
  * 优点三：允许上层节点逐步学习缓存路径，因为是逐级向上反馈，上面的节点知道整个完整路径了，因此下次查找时由于完整路径的缓存能提高查找速度。况且上面的节点不易改变，这样能永远记住完整路径，允许越层沟通，如果已经知道该传给谁

## DNS（Domain Name System）

> 名字到IP的映射

由于资源都在全球各地的服务器上，分布式是不可避免的。如果想要中心化DNS，就不需要规模化，因为你只关心你想要联系的域名，其他域名都离你很远

* 使用UDP传递消息，容易丢失，因为扔下消息就走没有任何反馈对方是否收到，但即便这样，客户端再发送一次消息即可，成本低
* 客户端决定是否超时和是否再次发送请求
* 支持迭代和递归，如果采用递归，客户端无法强迫停止，为了减少延迟，客户端可以一次性发送多个请求

