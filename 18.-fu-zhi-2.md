# 18.复制2

## 以数据为中心的一致性

### 保持一致性的四个规则：

* 单调读：`r1[x]-r2[x]`，r2\[x\]必须至少跟r1\[x\]看到一样的最新数据
* 单调写：`w1[x]-w2[x]`，w2\[x\]在w2\[x\]修改的基础上修改
* 读你的写：`w[x]-r[x]`，r\[x\]读取w\[x\]写修改后的数据
* 写跟着读：`r[x]-w[x]`，w\[x\]在r\[x\]读的数据上进行修改

### 几种不同的背景下如何复制

* 永久性的复制：当你从网上下载一个APP到本地时，你可能会被问到要从哪个城市的端口下载镜像文件，这些基于城市的端口让数据离用户更近了
* 服务器初始化的复制：**缓存和复制的区别：缓存是指缓存系统从原始的服务器上拉取缓存，复制时指复制系统将数据推到网络的各个副本来保持镜像文件的统一。**复制取决于请求。
* 客户端初始化的复制：例如浏览器缓存。

## 广播更新

> 即复制的算法

### 问题1:广播什么？

* 服务器A更新了文件，然后告诉B“你的文件无效了”。这种方式消息是短小并且是单向发送一次即可
* 服务器A更新了文件，然后记录下整个更新操作日志，将这个日志传递给服务器B，然后B按照同样的操作更新了文件
* 服务器A更新了文件，将这个最新的文件传给服务器B替代旧文件。这种方法不普遍，一旦这个文件很大，代价就会很高

### 问题2:谁来广播（消息发送方和接收方）？

> 取决于效率和延迟

* 服务器推送更新？这样服务器只用发送`put`请求给相应的客户端，这样节省了一半的消息量。但是服务器的工作量就很巨大，因为它需要记住所有事情，例如记住哪个客户端需要同步更新哪个文件
* 客户端拉取更新？客户端询问服务器“可以发送给我最新更新么？”服务器说“可以”然后将更新发给客户。这样就需要往返双倍的消息。

高级别的方法：基于租约将功能`put`转换成`pull`。一开始用`put`方法，一旦数据量变大（超过租约）了，就改成`pull`方法。

### 传染协议

> 两个副本端努力修正非一致性，从而达到最终一致

例如：  
 端口1只有最新的文件`x`，端口2有最新的文件`x`和`y`，此时他们不是一致的。端口1执行了`w1[x]`，端口2执行了`w2[x]`，新的操作`r1[y]`请求端口1，端口1没有文件`y`，于是将这个请求传给端口2，端口2执行完了`r1[y]`后发送消息给端口1，“我执行完了`r1[y]`，顺便告诉你我也执行了`w2[x]`”。为了达到最终的一致性，端口1就会丢弃`w1[x]`操作，先执行`w2[x]`，再执行`w1[x]`。

这种机制非常流行，此协议最后将这个机制像传染病一样传递给所有的端口直至最终一致性。

## 以客户端为中心的一致性协议模型

* 远程服务器端写操作使一致性：以远程服务器端为首领执行所有操作，执行完后这个客户端将更新传递给其他所有服务器端达到最终一致性。其他服务器响应客户端“完成任务”。
* 本地客户端写操作使一致性：远程服务器端为旧首领，本地客户端新建一个副本为新的首领（从就首领那里复制下来），所有写操作都必须在本地新首领上进行。一旦完成操作更新所有的远程服务器上的副本，然后新首领响应客户端“完成任务”。

### 基于仲裁的协议

> 通过投票来决定是否进行读或者写

`N_r`: 读操作获得的票数   
 `V_r`: 读操作要求的票数  
 `N_w`: 写操作获得的票数  
 `V_w`: 写操作要求的票数  
 `V`: 系统设置一共拥有的票数

仲裁系统设计的两个条件（设计就是决定`V_r=？，V_w=？`）：

* `V_r+V_w>V`：读这点保证了写操作不允许同时进行，必须有先后顺序，例如先写后读，那么读操作一定可以看到修改后的最新状态，正是因为端口投票的重叠确保从同意读操作的端口中至少看到一个最新的副本。这正是仲裁次协议的强大之处。
* `V_w>V/2`: 如果这个条件不满足，两个读操作会同时发生在不同的副本上，这样两部分的副本完全不重叠不相同，无法达到一致性。

极端情况：`V_r=1(无论多少)，V_w=V`。写操作发生在所有的端口，读操作发生在任意一个端口都能读到最新的文件，这种方法是可行的，但是就失去了仲裁的意义，因为非常不高效，既然同时修改所有的副本，就是**渴望/同步更新**，代价非常昂贵。这不属于仲裁协议的设计。

**注意：当设计仲裁系统时，运用所需最少的投票达到效果，因为越少的投票意味着越少的消息，反之代价越高速度越慢。**

